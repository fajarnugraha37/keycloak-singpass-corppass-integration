{"version":3,"file":"shared-DruKi8Dd-mgwkhzym.js","sources":["../../web/src/shared/util.js","../../web/src/shared/sched.js"],"sourcesContent":["export function safeParse(s) {\r\n    try { return s == null ? null : JSON.parse(s); }\r\n    catch { return null; }\r\n}\r\n\r\nexport function read(key, fallback) {\r\n    try {\r\n        const raw = localStorage.getItem(key);\r\n        return raw == null ? fallback : JSON.parse(raw);\r\n    } catch { return fallback; }\r\n}\r\n\r\nexport function throttle(fn, ms) {\r\n    let id = 0, pending = false;\r\n    return function () {\r\n        if (pending) return;\r\n        pending = true;\r\n        clearTimeout(id);\r\n        id = setTimeout(() => { pending = false; fn(); }, ms);\r\n    };\r\n}\r\n\r\nexport function load(key, fallback) {\r\n    try {\r\n        const raw = localStorage.getItem(key);\r\n        return raw ? JSON.parse(raw) : structuredClone(fallback);\r\n    } catch {\r\n        return structuredClone(fallback);\r\n    }\r\n}\r\n\r\nexport function saveIdle(key, value) {\r\n    const doSave = () => localStorage.setItem(key, JSON.stringify(value));\r\n    (window.requestIdleCallback || setTimeout)(doSave, 0);\r\n}\r\n\r\nexport function hideLoading() {\r\n    const el = document.getElementById('loading-overlay');\r\n    if (el) el.classList.add('hidden');\r\n}\r\n\r\nexport function showLoading() {\r\n    const el = document.getElementById('loading-overlay');\r\n    if (el) el.classList.remove('hidden');\r\n}\r\n\r\nexport async function callApi(path, token, method = \"GET\") {\r\n    const res = await fetch(path, {\r\n        method: method,\r\n        headers: token ? { Authorization: `Bearer ${token}` } : {}\r\n    });\r\n    const text = await res.text();\r\n    return { ok: res.ok, status: res.status, body: text };\r\n}\r\n\r\nexport function log(el, msg) {\r\n    const pre = document.getElementById(el);\r\n    pre.textContent = (pre.textContent + \"\\n\" + msg).trim();\r\n}\r\n\r\nexport function b64decode(str) {\r\n    try {\r\n        return JSON.parse(atob(str.replace(/-/g, '+').replace(/_/g, '/')));\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Encode a string or object into a base64 string.\r\n * If an object is provided it will be JSON.stringified before encoding.\r\n *\r\n * @param {string|object} input\r\n * @returns {string} base64 encoded string\r\n */\r\nexport function base64Encode(input) {\r\n    if (input === undefined || input === null) return '';\r\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\r\n    return Buffer.from(str, 'utf8').toString('base64');\r\n}\r\n\r\n/**\r\n * Decode a base64 string into either a string or an object.\r\n * If the decoded payload is valid JSON, the parsed object is returned,\r\n * otherwise the raw UTF-8 string is returned.\r\n *\r\n * @param {string} b64\r\n * @returns {string|object}\r\n */\r\nexport function base64Decode(b64) {\r\n    if (!b64) return '';\r\n    const str = Buffer.from(b64, 'base64').toString('utf8');\r\n    try {\r\n        return JSON.parse(str);\r\n    } catch (e) {\r\n        return str;\r\n    }\r\n}\r\n","export const hasPTSA = typeof scheduler !== 'undefined' && typeof scheduler.postTask === 'function';\r\n\r\n/**\r\n * Schedule a function with priority. Returns { signal, cancel } to abort.\r\n * @param {Function} fn\r\n * @param {('user-blocking'|'user-visible'|'background')} priority\r\n * @param {number} [delayMs] optional delay\r\n */\r\nexport function scheduleTask(fn, priority = 'background', delayMs = 0) {\r\n    const ac = new AbortController();\r\n    const { signal } = ac;\r\n\r\n    if (!hasPTSA) {\r\n        // Fallback: delay -> setTimeout, then microtask via Promise.\r\n        const id = setTimeout(() => { if (!signal.aborted) Promise.resolve().then(fn); }, delayMs);\r\n        return { signal, cancel: () => { ac.abort(); clearTimeout(id); } };\r\n    }\r\n\r\n    if (delayMs > 0) {\r\n        const id = setTimeout(() => {\r\n            if (signal.aborted) return;\r\n            scheduler.postTask(fn, { priority, signal }).catch(() => { });\r\n        }, delayMs);\r\n        return { signal, cancel: () => { ac.abort(); clearTimeout(id); } };\r\n    }\r\n\r\n    const task = scheduler.postTask(fn, { priority, signal });\r\n    return { signal, cancel: () => ac.abort() };\r\n}\r\n\r\n/** Cooperative yielding for long loops */\r\nexport async function cooperativeYield(priority = 'background') {\r\n    if (hasPTSA && scheduler.yield) {\r\n        await scheduler.yield({ priority });\r\n    } else {\r\n        // Fallback micro-yield\r\n        await new Promise(requestAnimationFrame);\r\n    }\r\n}"],"names":["hideLoading","el","showLoading","callApi","path","token","method","res","text","log","msg","pre"],"mappings":"AAoCO,SAASA,GAAc,CAC1B,MAAMC,EAAK,SAAS,eAAe,iBAAiB,EAChDA,GAAIA,EAAG,UAAU,IAAI,QAAQ,CACrC,CAEO,SAASC,GAAc,CAC1B,MAAMD,EAAK,SAAS,eAAe,iBAAiB,EAChDA,GAAIA,EAAG,UAAU,OAAO,QAAQ,CACxC,CAEO,eAAeE,EAAQC,EAAMC,EAAOC,EAAS,MAAO,CACvD,MAAMC,EAAM,MAAM,MAAMH,EAAM,CAC1B,OAAQE,EACR,QAASD,EAAQ,CAAE,cAAe,UAAUA,CAAK,EAAE,EAAK,CAAA,CAChE,CAAK,EACKG,EAAO,MAAMD,EAAI,OACvB,MAAO,CAAE,GAAIA,EAAI,GAAI,OAAQA,EAAI,OAAQ,KAAMC,EACnD,CAEO,SAASC,EAAIR,EAAIS,EAAK,CACzB,MAAMC,EAAM,SAAS,eAAeV,CAAE,EACtCU,EAAI,aAAeA,EAAI,YAAc;AAAA,EAAOD,GAAK,MACrD,CC1DuB,OAAO,UAAc,KAAsB,UAAU"}